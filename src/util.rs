//! Contains helper functions and structures.
//!

use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};

/// A structure to give an unique identifier within the library to the application in use
pub struct IDMachine {
    /// Application unique identifier
    id: usize,
}

impl IDMachine {
    /// Creates a new `IDMachine`
    ///
    /// # Returns
    /// An unique identifier (i.e, 0 because is the default value given)
    ///
    /// # Arguments
    /// No arguments
    pub fn new() -> IDMachine {
        IDMachine { id: 0 }
    }

    /// Fetch the unique identifier due to a new element requiring an identifier
    ///
    /// # Returns
    /// The new unique identifier
    ///
    /// # Arguments
    /// No arguments
    pub fn fetch_id(&mut self) -> usize {
        self.id += 1;
        self.id
    }
}

/// Queue data structure
///
/// A queue is a data structure that follows the pattern First item In is the 
/// First item Out (FIFO). The items added (enqueued) are always added at the 
/// end and the item removed (dequeues) are always the first of the queue.
pub struct Queue<T> {
    /// Vector of elements <T>
    pub queue: Vec<T>,
}

impl<T> Queue<T> {
    /// Creates a new `Queue`
    ///
    /// # Returns
    /// An empty queue
    ///
    /// # Arguments
    /// No arguments
    pub fn new() -> Self {
        Queue { 
            queue: Vec::new() 
        }
    }

    /// Inserts a new item at the end of the queue
    ///
    /// # Returns
    /// No returns
    ///
    /// # Arguments
    /// * `item` - the item to be inserted
    pub fn enqueue(&mut self, item: T) {
        self.queue.push(item)
    }

    /// Removes the first item of the queue
    ///
    /// # Returns
    /// The first item of the queue
    ///
    /// # Arguments
    /// No arguments
    pub fn dequeue(&mut self) -> Option<&T> {
        self.queue.first()
    }

    /// Gets the queue size
    ///
    /// # Returns
    /// The queue size
    ///
    /// # Arguments
    /// No arguments
    pub fn lenght(&self) -> usize {
        self.queue.len()
    }

    /// Tells whether the queue is empty
    ///
    /// # Returns
    /// True if the queue is empty, otherwise false
    ///
    /// # Arguments
    /// No arguments
    pub fn is_empty(&self) -> bool {
        self.queue.is_empty()
    }
}

/// A color represented in the RGB 8-bit color space
#[derive(Clone, Copy)]
pub struct Color {
    /// Transparency component, 0 to 255
    pub a: u8,
    /// Red component, 0 to 255
    pub r: u8,
    /// Green component, 0 to 255
    pub g: u8,
    /// Blue component, 0 to 255
    pub b: u8,
}

impl Color {
    /// Creates a new `Color`
    ///
    /// # Returns
    /// The color generated by the given RGB 8-bit color code
    ///
    /// # Arguments
    /// * `a` - transparency value from 0 to 255
    /// * `r` - red value from 0 to 255
    /// * `g` - green value from 0 to 255
    /// * `b` - blue value from 0 to 255
    pub fn new(a: u8, r: u8, g: u8, b: u8) -> Color {
        Color {
            a: a,
            r: r,
            g: g,
            b: b,
        }
    }

    /// Creates a new `Color` from hexadecimal color code
    ///
    /// # Returns
    /// The color generated by the given hexadecimal color code
    ///
    /// # Arguments
    /// * `hex` - hexadecimal color code
    pub fn from_hex(hex: u32) -> Color {
        Color {
            a: ((hex >> 24) & 0xff) as u8,
            r: ((hex >> 16) & 0xff) as u8,
            g: ((hex >> 8) & 0xff) as u8,
            b: (hex & 0xff) as u8,
        }
    }
}

/// A 2D vector, containing an x and a y component. Vector2Ds can be added to or 
/// subtracted from one-another, and they can be mulitplied and divided by scalar 
/// values.
#[derive(Clone, Copy)]
pub struct Vector2D {
    // Position of the 2D vector on x-axis of a two-dimensional space
    pub x: f64,
    // Position of the 2D vector on y-axis of a two-dimensional space
    pub y: f64,
}

impl Vector2D {
    /// Creates a new `Vector2D`
    ///
    /// # Returns
    /// The positioned vector
    ///
    /// # Arguments
    /// * `x` - value of the vector position on x-axis of a two-dimensional space
    /// * `y` - value of the vector position on y-axis of a two-dimensional space
    pub fn new(x: f64, y: f64) -> Self {
        Self { x: x, y: y }
    }

    /// Creates a new `Vector2D` from a tuple
    ///
    /// # Returns
    /// The positioned vector
    ///
    /// # Arguments
    /// * `tuple` - tuple of values with `x` and `y` values within
    pub fn from_tuple(tuple: (f64, f64)) -> Self {
        Self {
            x: tuple.0,
            y: tuple.1,
        }
    }

    /// Creates a new `Vector2D` based on the minimum position values between
    /// the vector itself and another one
    ///
    /// # Returns
    /// The repositioned vector
    ///
    /// # Arguments
    /// * `other` - vector to be compared
    pub fn min(self, other: Self) -> Self {
        Self {
            x: self.x.min(other.x),
            y: self.y.min(other.y),
        }
    }
}

impl Add for Vector2D {
    type Output = Self;

    /// Creates a new `Vector2D` as a result of adding two vectors (itself and another)
    ///
    /// # Returns
    /// A new vector resulting from the addition of the two vectors
    ///
    /// # Arguments
    /// * `other` - vector to add
    fn add(self, other: Self) -> Self {
        Self {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

impl Add<f64> for Vector2D {
    type Output = Self;

    /// Creates a new `Vector2D` as a result of adding two vectors (itself and another 
    /// floating 64-bits vector)
    ///
    /// # Returns
    /// A new vector resulting from the addition of the two vectors
    ///
    /// # Arguments
    /// * `other` - vector to add
    fn add(self, other: f64) -> Self {
        Self {
            x: self.x + other,
            y: self.y + other,
        }
    }
}

impl AddAssign for Vector2D {
    /// Increments the position of a vector into the current `Vector2D` position
    ///
    /// # Returns
    /// The repositioned vector
    ///
    /// # Arguments
    /// * `other` - vector to increment
    fn add_assign(&mut self, other: Self) {
        *self = Self {
            x: self.x + other.x,
            y: self.y + other.y,
        };
    }
}

impl AddAssign<f64> for Vector2D {
    /// Increments the position of a floating 64-bits vector into the current `Vector2D` position
    ///
    /// # Returns
    /// The repositioned vector
    ///
    /// # Arguments
    /// * `other` - vector to increment
    fn add_assign(&mut self, other: f64) {
        *self = Self {
            x: self.x + other,
            y: self.y + other,
        };
    }
}

impl Sub for Vector2D {
    type Output = Self;

    /// Creates a new `Vector2D` as a result of subtracting two vectors (itself and another)
    ///
    /// # Returns
    /// A new vector resulting from the subtraction of the two vectors
    ///
    /// # Arguments
    /// * `other` - vector to subtract
    fn sub(self, other: Self) -> Self::Output {
        Self {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}

impl Sub<f64> for Vector2D {
    type Output = Self;

    /// Creates a new `Vector2D` as a result of subtracting two vectors (itself and another 
    /// floating 64-bits vector)
    ///
    /// # Returns
    /// A new vector resulting from the subtraction of the two vectors
    ///
    /// # Arguments
    /// * `other` - vector to subtract
    fn sub(self, other: f64) -> Self::Output {
        Self {
            x: self.x - other,
            y: self.y - other,
        }
    }
}

impl SubAssign for Vector2D {
    /// Subtract the position of a vector with the current `Vector2D` position
    ///
    /// # Returns
    /// The repositioned vector
    ///
    /// # Arguments
    /// * `other` - vector to subtract
    fn sub_assign(&mut self, other: Self) {
        *self = Self {
            x: self.x - other.x,
            y: self.y - other.y,
        };
    }
}

impl SubAssign<f64> for Vector2D {
    /// Subtract the position of a floating 64-bits vector with the current `Vector2D` position
    ///
    /// # Returns
    /// The repositioned vector
    ///
    /// # Arguments
    /// * `other` - vector to subtract
    fn sub_assign(&mut self, other: f64) {
        *self = Self {
            x: self.x - other,
            y: self.y - other,
        };
    }
}

impl Mul for Vector2D {
    type Output = Self;

    /// Creates a new `Vector2D` as a result of multiplying two vectors (itself and another)
    ///
    /// # Returns
    /// A new vector resulting from the multiplication of the two vectors
    ///
    /// # Arguments
    /// * `other` - vector to multiply
    fn mul(self, other: Self) -> Self::Output {
        Self {
            x: self.x * other.x,
            y: self.y * other.y,
        }
    }
}

impl Mul<f64> for Vector2D {
    type Output = Self;

    /// Creates a new `Vector2D` as a result of multiplying two vectors (itself and another 
    /// floating 64-bits vector)
    ///
    /// # Returns
    /// A new vector resulting from the multiplication of the two vectors
    ///
    /// # Arguments
    /// * `other` - vector to multiply
    fn mul(self, other: f64) -> Self::Output {
        Self {
            x: self.x * other,
            y: self.y * other,
        }
    }
}

impl MulAssign for Vector2D {
    /// Multiply the position of a vector by the current `Vector2D` position
    ///
    /// # Returns
    /// The repositioned vector
    ///
    /// # Arguments
    /// * `other` - vector to multiply
    fn mul_assign(&mut self, other: Self) {
        *self = Self {
            x: self.x * other.x,
            y: self.y * other.y,
        };
    }
}

impl MulAssign<f64> for Vector2D {
    /// Multiply the position of a floating 64-bits vector by the current `Vector2D` position
    ///
    /// # Returns
    /// The repositioned vector
    ///
    /// # Arguments
    /// * `other` - vector to multiply
    fn mul_assign(&mut self, other: f64) {
        *self = Self {
            x: self.x * other,
            y: self.y * other,
        };
    }
}

impl Div for Vector2D {
    type Output = Self;

    /// Creates a new `Vector2D` as a result of divide two vectors (itself and another)
    ///
    /// # Returns
    /// A new vector resulting from the division of the two vectors
    ///
    /// # Arguments
    /// * `other` - vector to divide
    fn div(self, other: Self) -> Self::Output {
        Self {
            x: self.x / other.x,
            y: self.y / other.y,
        }
    }
}

impl Div<f64> for Vector2D {
    type Output = Self;

    /// Creates a new `Vector2D` as a result of divide two vectors (itself and another 
    /// floating 64-bits vector)
    ///
    /// # Returns
    /// A new vector resulting from the division of the two vectors
    ///
    /// # Arguments
    /// * `other` - vector to divide
    fn div(self, other: f64) -> Self::Output {
        Self {
            x: self.x / other,
            y: self.y / other,
        }
    }
}

impl DivAssign for Vector2D {
    /// Divides the the current `Vector2D` position by the position of a vector
    ///
    /// # Returns
    /// The repositioned vector
    ///
    /// # Arguments
    /// * `other` - vector to divide
    fn div_assign(&mut self, other: Self) {
        *self = Self {
            x: self.x / other.x,
            y: self.y / other.y,
        };
    }
}

impl DivAssign<f64> for Vector2D {
    /// Divides the the current `Vector2D` position by the position of a floating 64-bits vector
    ///
    /// # Returns
    /// The repositioned vector
    ///
    /// # Arguments
    /// * `other` - vector to divide
    fn div_assign(&mut self, other: f64) {
        *self = Self {
            x: self.x / other,
            y: self.y / other,
        };
    }
}
